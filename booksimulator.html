<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professional Writer's Book Visualizer</title>
    
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    
    <style>
        :root {
            /* Define dimensions for a common book size (e.g., 6" x 9") ratio */
            --page-width: 400px; 
            --page-height: 620px; 
            --sidebar-width: 200px;
        }
        
        body {
            font-family: 'Times New Roman', serif;
            display: flex;
            flex-direction: column; 
            align-items: center;
            background-color: #f0f0e8; 
            background-image: url("data:image/svg+xml,%3Csvg width='6' height='6' viewBox='0 0 6 6' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='%23ccc' fill-opacity='0.15' fill-rule='evenodd'%3E%3Cpath d='M5 0h1L0 6V5zm1 5v1H5z'/%3E%3C/g%3E%3C/svg%3E");
            margin: 0;
            padding: 0;
            min-height: 100vh;
            overflow: hidden; 
        }

        /* --- LEFT Sidebar (Collapsible - Navigation & Search) --- */
        .sidebar-left {
            position: fixed;
            top: 0;
            left: 0;
            width: var(--sidebar-width);
            height: 100%;
            background-color: #2c3e50; 
            color: white;
            padding: 20px 10px;
            overflow-y: auto;
            box-shadow: 4px 0 10px rgba(0, 0, 0, 0.4);
            transform: translateX(-100%); 
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); 
            z-index: 1000;
            font-family: Arial, sans-serif;
        }
        .sidebar-left.active { transform: translateX(0); }
        .sidebar-left h2 { margin-top: 0; border-bottom: 1px solid #4a637a; padding-bottom: 10px; font-size: 1.2em; color: #ecf0f1; }
        .page-list-item { padding: 8px 6px; margin-bottom: 5px; cursor: pointer; border-radius: 4px; font-size: 0.9em; transition: background-color 0.2s; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .page-list-item:hover { background-color: #3e5a76; }
        
        /* --- Burger Icon --- */
        #sidebar-toggle {
            position: fixed;
            top: 15px;
            left: 15px;
            z-index: 1001;
            cursor: pointer;
            color: #2c3e50;
            font-size: 32px;
            background: white;
            border-radius: 5px;
            padding: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            line-height: 1;
        }

        /* --- RIGHT Toolbar (Fixed - Editing & Controls) --- */
        .toolbar-right {
            position: fixed;
            top: 0;
            right: 0;
            width: 70px; 
            height: 100%;
            background-color: #ffffff;
            box-shadow: -4px 0 10px rgba(0, 0, 0, 0.1);
            z-index: 50;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px 0;
            gap: 10px;
            overflow-y: auto;
        }
        
        /* UI Improvement: Shared Button Styles */
        .toolbar-right button {
            width: 50px;
            height: 50px;
            border: none;
            cursor: pointer;
            background: none;
            color: #555;
            font-size: 24px;
            line-height: 1;
            transition: color 0.2s, background-color 0.2s;
        }
        
        .toolbar-right button:hover {
            color: #1abc9c; 
            background-color: #e8f5e9;
            border-radius: 4px;
        }
        
        /* Navigation Controls inside Right Toolbar */
        .controls-nav {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 5px 0;
            border-bottom: 1px solid #ddd; 
            width: 90%;
        }
        .controls-nav button { margin: 5px 0; font-size: 20px; color: #3498db; }
        .controls-nav label { font-size: 0.8em; margin-top: 5px; color: #333; }
        .controls-nav input[type="number"] { width: 40px; text-align: center; margin-bottom: 5px; padding: 4px; border: 1px solid #ccc; }
        
        /* Save Button Styling (Green) */
        #save-all-btn-toolbar { 
            color: white !important; 
            background-color: #2ecc71 !important; 
            font-size: 14px !important; 
            padding: 8px !important; 
            margin-top: 10px; 
            width: 60px !important; 
            height: auto !important; 
        }
        
        /* DELETE Button Styling (Red) */
        #delete-spread-btn {
            color: white !important;
            background-color: #e74c3c !important;
            font-size: 14px !important; 
            padding: 8px !important; 
            width: 60px !important; 
            height: auto !important; 
        }

        /* --- Main Content Area --- */
        .main-content {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100vh;
        }

        /* --- Book Structure --- */
        .book-container {
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: center;
        }

        .page {
            width: var(--page-width); 
            height: var(--page-height);
            background-color: #fffaf0; 
            border: 1px solid #dcdcdc; 
            padding: 30px; 
            padding-bottom: 40px; 
            box-sizing: border-box;
            box-shadow: 10px 10px 25px rgba(0, 0, 0, 0.2); 
            position: relative;
            cursor: text; 
            font-size: 16px; 
            line-height: 1.6;
            overflow: hidden; 
        }
        
        /* The editable area now only contains the content */
        .page-content {
            height: 100%; 
            overflow: hidden; 
        }
        
        /* The search highlight should be a simple mark element */
        mark.search-highlight {
            background-color: yellow; 
            color: black;
            padding: 0 1px;
        }
        
        /* --- Page Number Positioning (Fixed) --- */
        .page-number {
            position: absolute; 
            bottom: 15px; 
            left: 0;
            right: 0;
            text-align: center;
            font-size: 0.8em;
            color: #7f8c8d; 
            pointer-events: none;
        }
        
        /* Reset Button Styling */
        #clear-storage-btn {
            background-color: #e74c3c;
            width: 90%;
            margin-top: 10px;
            font-size: 12px !important;
            padding: 10px;
        }
    </style>
</head>
<body tabindex="0"> 
    
    <i class="material-icons" id="sidebar-toggle" title="Toggle Search/Navigation">menu</i>

    <div class="sidebar-left" id="sidebar-left">
        <h2>Book Navigation</h2>
        <input type="text" id="search-input" placeholder="Dynamic Search..." style="width: 90%; margin-bottom: 10px;">
        <div id="page-list">
            </div>
        <button id="save-all-btn" title="Manual Save" style="background-color: #2ecc71; width: 90%; margin-top: 20px;">Save All Content</button>
        
        <button id="clear-storage-btn"><i class="material-icons" style="font-size: 16px;">delete_sweep</i> CLEAR CORRUPTED DATA</button>
    </div>

    <div class="toolbar-right">
        
        <div class="controls-nav">
            <button id="prev-page-btn" title="Previous Spread (or Left Arrow)"><i class="material-icons">arrow_back</i></button>
            <label for="page-input">Page</label>
            <input type="number" id="page-input" min="1" value="1" step="2">
            <button id="go-btn" title="Go to Page"><i class="material-icons">send</i></button>
            <button id="next-page-btn" title="Next Spread (or Right Arrow)"><i class="material-icons">arrow_forward</i></button>
        </div>
        
        <span style="border-bottom: 1px solid #ddd; width: 90%; margin: 5px 0;"></span>
        
        <button title="Bold" onclick="formatDoc('bold')"><i class="material-icons">format_bold</i></button>
        <button title="Italic" onclick="formatDoc('italic')"><i class="material-icons">format_italic</i></button>
        <button title="Underline" onclick="formatDoc('underline')"><i class="material-icons">format_underlined</i></button>
        
        <input type="color" id="color-picker" title="Text Color" onchange="formatDoc('foreColor', this.value)">
        
        <span style="border-bottom: 1px solid #ddd; width: 90%; margin: 5px 0;"></span>

        <button title="Align Left" onclick="formatDoc('justifyLeft')"><i class="material-icons">format_align_left</i></button>
        <button title="Center" onclick="formatDoc('justifyCenter')"><i class="material-icons">format_align_center</i></button>
        <button title="Align Right" onclick="formatDoc('justifyRight')"><i class="material-icons">format_align_right</i></button>
        <button title="Justify" onclick="formatDoc('justifyFull')"><i class="material-icons">format_align_justify</i></button>
        
        <span style="border-bottom: 1px solid #ccc; width: 90%; margin: 10px 0;"></span>

        <button id="delete-spread-btn" title="Delete Current Spread"><i class="material-icons">delete_forever</i></button>
        <button title="Remove Formatting" onclick="formatDoc('removeFormat')"><i class="material-icons">format_clear</i></button>
        <button id="save-all-btn-toolbar" title="Save All Content (F10)" style="background-color: #2ecc71;"><i class="material-icons">save</i></button>
        
    </div>

    <div class="main-content">
        
        <div class="book-container">
            <div class="page" id="left-page" data-page-index="0">
                <div class="page-content" id="left-content" contenteditable="true"></div> 
                <div class="page-number" id="left-number">1</div>
            </div>
            <div class="page" id="right-page" data-page-index="1">
                <div class="page-content" id="right-content" contenteditable="true"></div>
                <div class="page-number" id="right-number">2</div>
            </div>
        </div>
    </div>
    
    <script>
        // --- Setup and Data ---

        let currentPage = 1;
        const BOOK_STORAGE_KEY = 'writerBookContent';
        
        // Load content from Local Storage or use a mock if none exists
        let bookContent = JSON.parse(localStorage.getItem(BOOK_STORAGE_KEY)) || [
            `<p style="text-align: center;"><strong><span style="font-size: 1.5em;">Chapter 1: The Start of Your Story</span></strong></p><p>This is page 1. Your page is ready for writing. Paste a lot of text here! The system will now correctly cut the text that overflows the box and push it sequentially to the next page.</p><p>The issue where only the chapter title showed has been fixed by ensuring the measurement is accurate for all content.</p>`,
            `<p>Page 2. This page is empty, waiting for the overflow text from the previous page.</p>`,
            `<p><strong>Chapter 2: Clean Editing</strong></p><p>You can now safely edit the text on this page without worrying about accidental clicks or corrupting the HTML. The flow should be smooth and predictable now.</p>`,
            `<p>Page 4. Continue typing here.</p>`,
            `<p><strong>Page 5: Last Chapter</strong></p><p>Final page for testing purposes.</p>`,
            `<p>Page 6. End of demo content.</p>`
        ];

        // --- Rich Text Formatting Function (using document.execCommand) ---
        function formatDoc(command, value = null) {
            document.execCommand(command, false, value);
            
            const activeElement = document.activeElement;
            if (activeElement && activeElement.closest('.page')) {
                 activeElement.closest('.page-content').focus();
            }
        }
        window.formatDoc = formatDoc; 

        // --- CORE FUNCTION: Split Text and Cascade ---

        function splitContent(contentEl) {
            const pageEl = contentEl.closest('.page');
            let pageIndex = parseInt(pageEl.dataset.pageIndex);
            
            // Loop until the active page no longer overflows
            while (contentEl.scrollHeight > contentEl.clientHeight) {
                
                let overflowHTML = '';
                
                // 1. Create a dummy element to find the exact overflow point
                const tempDiv = contentEl.cloneNode(true);
                tempDiv.style.position = 'absolute';
                tempDiv.style.visibility = 'hidden';
                tempDiv.style.height = contentEl.clientHeight + 'px';
                tempDiv.style.width = contentEl.clientWidth + 'px';
                tempDiv.style.overflow = 'hidden';
                document.body.appendChild(tempDiv);
                
                // Iteratively remove children from the bottom until the content fits
                while (tempDiv.scrollHeight > tempDiv.clientHeight && tempDiv.lastChild) {
                    const lastChild = tempDiv.lastChild;
                    overflowHTML = lastChild.outerHTML ? lastChild.outerHTML + overflowHTML : lastChild.textContent + overflowHTML;
                    tempDiv.removeChild(lastChild);
                }
                
                document.body.removeChild(tempDiv);
                
                if (!overflowHTML) break; 

                // 2. Set the current page content to only the fitting part
                contentEl.innerHTML = tempDiv.innerHTML;
                
                // 3. Save the clean content for the current page
                // CRITICAL FIX: Ensure saved content is free of search highlights
                bookContent[pageIndex] = contentEl.innerHTML.replace(/<mark class="search-highlight">(.*?)<\/mark>/gi, '$1');
                
                // 4. Handle Next Page (Auto-Creation and Transfer)
                let nextPageIndex = pageIndex + 1;
                
                // Auto-create pages if necessary (in spreads of 2)
                if (nextPageIndex >= bookContent.length) {
                    bookContent.push(''); 
                    bookContent.push('');
                }
                
                // 5. Transfer the overflow to the next page, adding it to any existing content
                const cleanOverflowHTML = overflowHTML.replace(/<mark class="search-highlight">(.*?)<\/mark>/gi, '$1');
                bookContent[nextPageIndex] = cleanOverflowHTML + bookContent[nextPageIndex];
                
                // 6. Save the entire array to Local Storage
                localStorage.setItem(BOOK_STORAGE_KEY, JSON.stringify(bookContent));
                
                // 7. Determine next focus and page index
                
                let focusEl = null;
                if (pageIndex === currentPage - 1) {
                    // Overflow from LEFT page (Page N) flows to RIGHT page (Page N+1)
                    updateBookDisplay(); 
                    focusEl = document.getElementById('right-content'); 
                } else if (pageIndex === currentPage) {
                    // Overflow from RIGHT page (Page N+1) flows to LEFT page of next spread (Page N+2)
                    currentPage = nextPageIndex; // Navigate to new spread start
                    updateBookDisplay();
                    focusEl = document.getElementById('left-content');
                } else if (pageIndex > currentPage + 1) {
                    // Safety case: If overflowed several pages, navigate to the correct spread
                    currentPage = nextPageIndex % 2 === 0 ? nextPageIndex - 1 : nextPageIndex;
                    updateBookDisplay(); 
                    focusEl = document.getElementById('left-content');
                }
                
                // Force focus on the element containing the overflow text
                if (focusEl) focusEl.focus();

                // Advance the index for the next loop iteration (Page N -> Page N+1)
                pageIndex++;
            }
        }

        // --- Event Listener for Input and Overflow ---
        
        function checkAndHandleContent(event) {
            const contentEl = event.target;
            
            if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Delete', 'Backspace'].includes(event.key)) {
                return;
            }

            // 1. Force Page Break on Ctrl+Enter
            if (event.ctrlKey && event.key === 'Enter') {
                event.preventDefault();
                splitContent(contentEl);
                return;
            }

            // 2. Handle Overflow
            setTimeout(() => {
                if (contentEl.scrollHeight > contentEl.clientHeight) {
                    splitContent(contentEl);
                }
            }, 0);
        }
        
        // --- Page Update Functions ---

        function updatePageContent(index, contentId, numberId, defaultText) {
            const pageEl = document.getElementById(contentId.replace('-content', '-page'));
            const contentEl = document.getElementById(contentId);
            const numberEl = document.getElementById(numberId);

            if (index >= 0 && index < bookContent.length) {
                // Load clean content into the editable div
                contentEl.innerHTML = bookContent[index]; 
                numberEl.textContent = index + 1;
                pageEl.dataset.pageIndex = index; 
                
                contentEl.oninput = checkAndHandleContent; 
                contentEl.onpaste = (e) => {
                    e.preventDefault(); 
                    const text = (e.clipboardData || window.clipboardData).getData('text/html') || 
                                 (e.clipboardData || window.clipboardData).getData('text/plain');
                    document.execCommand('insertHTML', false, text); 
                    setTimeout(() => splitContent(contentEl), 0); 
                };

            } else {
                contentEl.innerHTML = defaultText;
                numberEl.textContent = '';
                pageEl.removeAttribute('contenteditable');
                contentEl.oninput = null;
                contentEl.onpaste = null;
            }
        }


        function updateBookDisplay() {
            const leftPageIndex = currentPage - 1;
            const rightPageIndex = currentPage;

            updatePageContent(leftPageIndex, 'left-content', 'left-number', `<p><h2>Cover/Start</h2>Click next to begin reading.</p>`);
            updatePageContent(rightPageIndex, 'right-content', 'right-number', `<p><h2>The End</h2>Thank you for visualizing your work!</p>`);
            
            document.getElementById('page-input').value = currentPage;
            document.getElementById('prev-page-btn').disabled = currentPage <= 1;
            document.getElementById('next-page-btn').disabled = currentPage + 1 >= bookContent.length;
            
            renderSidebar(document.getElementById('search-input').value.toLowerCase());
        }

        // --- DELETE SPREAD FEATURE ---

        function deleteCurrentSpread() {
            const leftIndex = currentPage - 1;
            const rightIndex = currentPage;

            if (bookContent.length <= 2) {
                alert("Cannot delete the last remaining spread!");
                return;
            }

            if (confirm(`Are you sure you want to permanently delete pages ${leftIndex + 1} and ${rightIndex + 1}?`)) {
                // 1. Get the content of the pages *after* the deleted spread
                let contentToShift = '';
                if (rightIndex + 1 < bookContent.length) {
                    contentToShift = bookContent[rightIndex + 1] + bookContent[rightIndex + 2];
                }

                // 2. Remove the two pages from the array
                bookContent.splice(leftIndex, 2);
                
                // 3. Insert the shifted content into the current page index
                if (contentToShift) {
                     bookContent[leftIndex] = contentToShift;
                }
                
                // 4. Adjust current page pointer after deletion
                if (leftIndex >= bookContent.length) {
                    currentPage = bookContent.length % 2 === 0 ? bookContent.length - 1 : bookContent.length;
                } else {
                    currentPage = leftIndex + 1;
                }

                // 5. Final save and trigger cascade (to re-flow shifted content)
                saveAllContent(false);
                splitContent(document.getElementById('left-content')); 
                updateBookDisplay();
                alert("Spread deleted and content successfully shifted up!");
            }
        }


        // --- Final Search Stability Fix: Uses DOM Range to Highlight ---

        function highlightText(element, pattern) {
            // Remove previous highlights
            element.innerHTML = element.innerHTML.replace(/<mark class="search-highlight">(.*?)<\/mark>/gi, '$1');
            
            if (!pattern) return;

            // Use a temporary clone to accurately highlight text without breaking HTML nodes
            function wrapText(node) {
                if (node.nodeType === 3) { // Text node
                    const text = node.nodeValue;
                    const regex = new RegExp(pattern, 'gi');
                    const highlightedText = text.replace(regex, (match) => `<mark class="search-highlight">${match}</mark>`);
                    
                    if (highlightedText !== text) {
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = highlightedText;
                        while (tempDiv.firstChild) {
                            node.parentNode.insertBefore(tempDiv.firstChild, node);
                        }
                        node.parentNode.removeChild(node);
                    }
                } else if (node.nodeType === 1 && node.nodeName !== 'MARK') { // Element node (skip existing marks)
                    Array.from(node.childNodes).forEach(wrapText);
                }
            }
            
            wrapText(element);
        }

        
        function renderSidebar(query = '') {
            const pageList = document.getElementById('page-list');
            pageList.innerHTML = ''; 

            let searchResults = [];

            // 1. Save content and remove highlights from data array before starting search
            saveAllContent(false); 
            
            // Re-load the current content to ensure we start the search on a clean slate
            updateBookDisplayContentsOnly(); 


            if (query.length > 0) {
                 bookContent.forEach((html, index) => {
                    const text = html.toLowerCase().replace(/<[^>]*>/g, ''); 
                    if (text.includes(query)) {
                        searchResults.push(index);
                    }
                 });
                 
                 // Apply highlighting directly to the visible DOM elements
                 highlightText(document.getElementById('left-content'), query);
                 highlightText(document.getElementById('right-content'), query);
            } else {
                 // Clear highlights from the visible DOM elements
                 document.getElementById('left-content').innerHTML = document.getElementById('left-content').innerHTML.replace(/<mark class="search-highlight">(.*?)<\/mark>/gi, '$1');
                 document.getElementById('right-content').innerHTML = document.getElementById('right-content').innerHTML.replace(/<mark class="search-highlight">(.*?)<\/mark>/gi, '$1');
            }

            // 3. Build the sidebar list
            for (let i = 0; i < bookContent.length; i += 2) {
                const spreadStartPage = i + 1;
                const spreadEndPage = i + 2;
                
                // Get snippet from the *clean* version of the content
                const plainText = bookContent[i].replace(/<[^>]*>/g, ''); 
                const snippet = plainText.substring(0, 30) + (plainText.length > 30 ? '...' : ''); 
                
                const listItem = document.createElement('div');
                listItem.className = 'page-list-item';
                
                if (searchResults.includes(i) || searchResults.includes(i + 1)) {
                    listItem.classList.add('highlight-match');
                }
                
                listItem.innerHTML = `<strong>Pgs ${spreadStartPage}-${spreadEndPage}:</strong> ${snippet}`;
                listItem.dataset.page = spreadStartPage;
                listItem.onclick = () => { goToSpecificPage(spreadStartPage); };

                pageList.appendChild(listItem);
            }
        }
        
        function updateBookDisplayContentsOnly() {
            const leftIndex = currentPage - 1;
            const rightIndex = currentPage;
            
            // Get content directly from the bookContent array (which is clean)
            if (leftIndex >= 0 && leftIndex < bookContent.length) {
                document.getElementById('left-content').innerHTML = bookContent[leftIndex];
            }
            if (rightIndex < bookContent.length) {
                document.getElementById('right-content').innerHTML = bookContent[rightIndex];
            }
        }

        function saveAllContent(showAlert = true) {
            const leftContentEl = document.getElementById('left-content');
            const rightContentEl = document.getElementById('right-content');
            
            const extractAndClean = (contentDiv, pageElId) => {
                const pageEl = document.getElementById(pageElId);
                const index = parseInt(pageEl.dataset.pageIndex);

                if (contentDiv && !isNaN(index) && index >= 0 && index < bookContent.length) {
                    // FINAL CLEANUP: Remove any temporary search highlights before saving to storage
                    let content = contentDiv.innerHTML.replace(/<mark class="search-highlight">(.*?)<\/mark>/gi, '$1');
                    bookContent[index] = content.trim();
                }
            };

            extractAndClean(leftContentEl, 'left-page');
            extractAndClean(rightContentEl, 'right-page');
            
            localStorage.setItem(BOOK_STORAGE_KEY, JSON.stringify(bookContent));
            
            if (showAlert) {
                alert("All content saved successfully to your browser!");
            }
        }

        function goToNextPage() {
            if (currentPage + 2 <= bookContent.length) {
                saveAllContent(false); 
                currentPage += 2;
                updateBookDisplay();
            }
        }

        function goToPreviousPage() {
            if (currentPage - 2 >= 1) {
                saveAllContent(false); 
                currentPage -= 2;
                updateBookDisplay();
            } else if (currentPage > 1) {
                saveAllContent(false);
                currentPage = 1;
                updateBookDisplay();
            }
        }

        function goToSpecificPage(targetPageNum) {
            saveAllContent(false); 
            let targetPage = targetPageNum || parseInt(document.getElementById('page-input').value);

            if (isNaN(targetPage) || targetPage < 1) {
                alert("Please enter a valid page number (1 or greater).");
                return;
            }

            const totalPages = bookContent.length;
            if (targetPage > totalPages) {
                targetPage = totalPages; 
            }
            
            currentPage = (targetPage % 2 === 0) ? targetPage - 1 : targetPage;
            
            updateBookDisplay();
        }
        
        function clearCorruptedStorage() {
            if (confirm("WARNING: This will permanently DELETE ALL saved book progress and restart the application with default text. Proceed?")) {
                localStorage.removeItem(BOOK_STORAGE_KEY);
                location.reload();
            }
        }

        // --- KEYBOARD Navigation Listener ---
        document.addEventListener('keydown', function(event) {
            if (event.target.tagName !== 'INPUT' && event.target.tagName !== 'TEXTAREA' && event.target.id !== 'search-input' && event.target.id !== 'page-input') {
                if (event.key === 'ArrowRight' || event.key === 'Right') {
                    goToNextPage();
                    event.preventDefault(); 
                } else if (event.key === 'ArrowLeft' || event.key === 'Left') {
                    goToPreviousPage();
                    event.preventDefault(); 
                } else if (event.key === 'F10') {
                    saveAllContent(true);
                    event.preventDefault();
                }
            }
        });


        // --- Event Listeners ---
        
        document.getElementById('sidebar-toggle').addEventListener('click', () => {
            const sidebar = document.getElementById('sidebar-left');
            sidebar.classList.toggle('active');
            if (!sidebar.classList.contains('active')) {
                saveAllContent(false);
            }
        });

        document.getElementById('next-page-btn').addEventListener('click', goToNextPage);
        document.getElementById('prev-page-btn').addEventListener('click', goToPreviousPage);
        document.getElementById('go-btn').addEventListener('click', () => goToSpecificPage());
        
        document.getElementById('delete-spread-btn').addEventListener('click', deleteCurrentSpread);
        
        document.getElementById('save-all-btn').addEventListener('click', () => saveAllContent(true));
        document.getElementById('save-all-btn-toolbar').addEventListener('click', () => saveAllContent(true)); 
        
        // CRITICAL FIX: Attach search to input listener 
        document.getElementById('search-input').addEventListener('input', () => renderSidebar(document.getElementById('search-input').value.toLowerCase()));

        // Fixing Edit/Navigation Conflict
        document.getElementById('left-content').addEventListener('click', (e) => e.currentTarget.focus());
        document.getElementById('right-content').addEventListener('click', (e) => e.currentTarget.focus());
        
        document.getElementById('clear-storage-btn').addEventListener('click', clearCorruptedStorage);


        // Initialization
        updateBookDisplay();
    </script>
</body>
</html>